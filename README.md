Это помогает понять, что это за «Redux» вещь в первую очередь. Что он делает? Какие проблемы он помогает мне решить? Зачем мне его использовать?

**Redux — это шаблон и библиотека для управления и обновления состояния приложения с помощью событий, называемых «действиями».** Он служит централизованным хранилищем состояния, которое необходимо использовать во всем приложении, с правилами, гарантирующими, что состояние может быть обновлено только предсказуемым образом.

### Почему я должен использовать Redux? [](https://redux.js.org/tutorials/essentials/part-1-overview-concepts#why-should-i-use-redux)

Redux помогает управлять «глобальным» состоянием — состоянием, необходимым для многих частей приложения.

**Шаблоны и средства, предоставляемые Redux, упрощают понимание того, когда, где, почему и как обновляется состояние в приложении, а также как логика приложения будет вести себя при этих изменениях**. Redux поможет вам написать код, который является предсказуемым и тестируемым, что дает вам уверенность в том, что ваше приложение будет работать так, как ожидалось.

### Когда следует использовать Redux? [](https://redux.js.org/tutorials/essentials/part-1-overview-concepts#when-should-i-use-redux)

Redux помогает вам справиться с общим управлением состоянием, но, как и любой инструмент, он имеет компромиссы. Есть больше концепций для изучения и больше кода для написания. Он также добавляет некоторую косвенность в ваш код и просит вас следовать определенным ограничениям. Это компромисс между краткосрочной и долгосрочной производительностью.

Redux более полезен, когда:

-   У вас есть большие объемы состояний приложения, которые необходимы во многих местах приложения
-   Состояние приложения часто обновляется с течением времени
-   Логика обновления этого состояния может быть сложной
-   Приложение имеет среднюю или большую кодовую базу, и над ним могут работать многие люди.

**Не все приложения нуждаются в Redux. Потратьте некоторое время, чтобы подумать о том, какое приложение вы создаете, и решить, какие инструменты лучше всего помогут решить проблемы, над которыми вы работаете.**

**ХОТИТЕ УЗНАТЬ БОЛЬШЕ?**

Если вы не уверены, является ли Redux хорошим выбором для вашего приложения, эти ресурсы содержат дополнительные рекомендации.

-   **[Когда (а когда нет) тянуться к Redux](https://changelog.com/posts/when-and-when-not-to-reach-for-redux)**
-   **[Дао Редукса, часть 1 - Реализация и намерение](https://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-1/)**
-   **[Redux FAQ: Когда следует использовать Redux?](https://redux.js.org/faq/general#when-should-i-use-redux)**
-   **[Возможно, вам не понадобится Redux](https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367)**

### Библиотеки и инструменты Redux

Redux - это небольшая автономная библиотека JS. Тем не менее, он обычно используется с несколькими другими пакетами:

### Реактив-Редукс

Redux может интегрироваться с любым фреймворком пользовательского интерфейса и чаще всего используется с React. **[React-Redux](https://react-redux.js.org/)** - это наш официальный пакет, который позволяет вашим компонентам React взаимодействовать с хранилищом Redux, считывая части состояния и отправляя действия для обновления хранилища.

### Инструментарий Redux

**[Redux Toolkit](https://redux-toolkit.js.org/)** - это наш рекомендуемый подход к написанию логики Redux. Он содержит пакеты и функции, которые, по нашему мнению, необходимы для создания приложения Redux. Redux Toolkit создает предлагаемые нами рекомендации, упрощает большинство задач Redux, предотвращает распространенные ошибки и облегчает написание приложений Redux.

### Расширение Redux DevTools

**[Расширение Redux DevTools](https://github.com/reduxjs/redux-devtools/tree/main/extension)** показывает историю изменений состояния в вашем хранилище Redux с течением времени. Это позволяет эффективно отлаживать приложения, в том числе с помощью мощных методов, таких как «отладка путешествий во времени».

## Термины и концепции Redux

Прежде чем мы углубимся в реальный код, давайте поговорим о некоторых терминах и концепциях, которые вам нужно знать, чтобы использовать Redux.

### Управление состоянием

Давайте начнем с рассмотрения небольшого компонента счетчика React. Он отслеживает число в состоянии компонента и увеличивает число при нажатии кнопки:

```jsx
function Counter() {
    // State: a counter value
    const [counter, setCounter] = useState(0)

    // Action: code that causes an update to the state when something happens
    const increment = () => {
        setCounter((prevCounter) => prevCounter + 1)
    }

    // View: the UI definition
    return (
        <div>
            Value: {counter} <button onClick={increment}>Increment</button>
        </div>
    )
}
```

Это автономное приложение со следующими частями:

-   СОСТОЯНИЕ, источник истины, который движет нашим приложением;
-   **Представление**, декларативное описание пользовательского интерфейса на основе текущего состояния
-   **Действия**, события, происходящие в приложении на основе вводимых пользователем данных, и запуск обновлений в состоянии

Вот небольшой пример **«одностороннего потока данных»**:

-   Состояние описывает состояние приложения в определенный момент времени
-   Пользовательский интерфейс отображается на основе этого состояния
-   Когда что-то происходит (например, пользователь нажимает кнопку), состояние обновляется в зависимости от того, что произошло.
-   Пользовательский интерфейс повторно отображается на основе нового состояния

![https://redux.js.org/assets/images/one-way-data-flow-04fe46332c1ccb3497ecb04b94e55b97.png](https://redux.js.org/assets/images/one-way-data-flow-04fe46332c1ccb3497ecb04b94e55b97.png)

Однако простота может разрушиться, когда у нас есть **несколько компонентов, которые должны совместно использовать и использовать одно и то же состояние**, особенно если эти компоненты расположены в разных частях приложения. Иногда это можно решить, [«подняв состояние» до](https://reactjs.org/docs/lifting-state-up.html) родительских компонентов, но это не всегда помогает.

Одним из способов решения этой проблемы является извлечение общего состояния из компонентов и помещение его в централизованное расположение за пределами дерева компонентов. При этом наше дерево компонентов становится большим «представлением», и любой компонент может получить доступ к состоянию или триггерным действиям, независимо от того, где они находятся в дереве!

Определяя и разделяя концепции, участвующие в управлении стейтом, и применяя правила, которые сохраняют независимость между взглядами и состояниями, мы придаем нашему коду большую структуру и удобство обслуживания.

Это основная идея Redux: единое централизованное место для хранения глобального состояния в приложении и конкретные шаблоны, которым необходимо следовать при обновлении этого состояния, чтобы сделать код предсказуемым.

### Неизменность

«Изменчивый» означает «мутирующий». Если что-то «неизменно», оно никогда не может быть изменено.

Все объекты и массивы JavaScript по умолчанию изменяемы. Если я создаю объект, я могу изменить содержимое его полей. Если я создаю массив, я также могу изменить содержимое:

```jsx
const obj = { a: 1, b: 2 }
// still the same object outside, but the contents have changed
obj.b = 3

const arr = ['a', 'b']
// In the same way, we can change the contents of this array
arr.push('c')
arr[1] = 'd'
```

Это называется *мутацией* объекта или массива. Это тот же объект или ссылка на массив в памяти, но теперь содержимое внутри объекта изменилось.

**Чтобы обновлять значения неизменно, код должен создавать *копии* существующих объектов/массивов, а затем изменять копии**.

Мы можем сделать это вручную, используя операторы распространения массива / объекта JavaScript, а также методы массива, которые возвращают новые копии массива вместо мутации исходного массива:

```jsx
const obj = {
    a: {
        // To safely update obj.a.c, we have to copy each piece
        c: 3,
    },
    b: 2,
}

const obj2 = {
    // copy obj
    ...obj,
    // overwrite a
    a: {
        // copy obj.a
        ...obj.a,
        // overwrite c
        c: 42,
    },
}

const arr = ['a', 'b']
// Create a new copy of arr, with "c" appended to the end
const arr2 = arr.concat('c')

// or, we can make a copy of the original array:
const arr3 = arr.slice()
// and mutate the copy:
arr3.push('c')
```

**Redux ожидает, что все обновления состояния будут выполняться неизменно**. О том, где и как это важно, мы рассмотрим чуть позже, а также о некоторых более простых способах написания неизменяемой логики обновления.

### Терминология

Есть несколько важных терминов Redux, с которыми вам нужно ознакомиться, прежде чем мы продолжим:

### Действия

**Действие** — это простой объект JavaScript с полем. **Действие можно рассматривать как событие, описывающее то, что произошло в приложении**.`type`

Поле должно быть строкой, которая придает этому действию описательное имя, например . Обычно мы пишем строку типа , где первая часть — это признак или категория, к которой относится это действие, а вторая часть — это конкретная вещь, которая произошла.`type"todos/todoAdded""domain/eventName"`

Объект действия может иметь другие поля с дополнительными сведениями о том, что произошло. По соглашению мы помещаем эту информацию в поле под названием .`payload`

Типичный объект действия может выглядеть следующим образом:

```jsx
const addTodoAction = {
    type: 'todos/todoAdded',
    payload: 'Buy milk',
}
```

### Создатели экшена

**Создатель действия** — это функция, которая создает и возвращает объект действия. Обычно мы используем их, поэтому нам не нужно каждый раз писать объект действия вручную:

```jsx
const addTodo = (text) => {
    return {
        type: 'todos/todoAdded',
        payload: text,
    }
}
```

### Редьюсеров

**Редьюсер** — это функция, которая получает ток и объект, решает, как при необходимости обновить состояние, и возвращает новое состояние: . **Редьюсер можно рассматривать как прослушиватель событий, который обрабатывает события на основе типа полученного действия (события).**`stateaction(state, action) => newState`

**ИНФОРМАЦИЯ**

Функции "Reducer" получили свое название, потому что они похожи на функцию обратного вызова, которую вы передаете методу `[Array.reduce(](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)`).

Редьюсеры *всегда* должны следовать некоторым определенным правилам:

-   Они должны вычислять только новое значение состояния на основе аргументов and`stateaction`
-   Им не разрешается изменять существующие . Вместо этого они должны вносить *неизменяемые обновления*, копируя существующие и внося изменения в скопированные значения.`statestate`
-   Они не должны выполнять асинхронную логику, вычислять случайные значения или вызывать другие «побочные эффекты».

Подробнее о правилах редьюсеров мы поговорим позже, в том числе о том, почему они важны и как им правильно следовать.

Логика внутри функций редьюсера обычно выполняет одну и ту же серию шагов:

-   Проверьте, заботится ли редьюсер об этом действии
    -   Если это так, создайте копию состояния, обновите копию новыми значениями и верните ее.
-   В противном случае верните существующее состояние без изменений.

Вот небольшой пример редьюсера, показывающий шаги, которые должен выполнять каждый редьюсер:

```jsx
const initialState = { value: 0 }

function counterReducer(state = initialState, action) {
    // Check to see if the reducer cares about this action
    if (action.type === 'counter/increment') {
        // If so, make a copy of `state`
        return {
            ...state,
            // and update the copy with the new value
            value: state.value + 1,
        }
    }
    // otherwise return the existing state unchanged
    return state
}
```

Редьюсеры могут использовать любую логику внутри, чтобы решить, каким должно быть новое состояние: , , циклы и так далее.`if/elseswitch`

### хранилище

Текущее состояние приложения Redux находится в объекте, называемом **хранилищем**.

Хранилище создается путем передачи редьюсера и имеет метод, который возвращает текущее значение состояния:`getState`

```jsx
import { configureStore } from '@reduxjs/toolkit'

const store = configureStore({ reducer: counterReducer })

console.log(store.getState())
// {value: 0}
```

### Отправка

В хранилище Redux есть метод с именем . **Единственный способ обновить состояние — вызвать `store.dispatch()` и передать объект действия**. Хранилище запустит свою функцию редьюсера и сохранит новое значение состояния внутри, и мы можем вызвать, чтобы получить обновленное значение:`dispatchgetState()`

```jsx
store.dispatch({ type: 'counter/increment' })

console.log(store.getState())
// {value: 1}
```

**Диспетчерские действия можно рассматривать как «запуск события»** в приложении. Что-то произошло, и мы хотим, чтобы хранилищ знал об этом. Редьюсеры действуют как слушатели событий, и когда они слышат интересующее их действие, они обновляют состояние в ответ.

Обычно мы призываем создателей действий отправить правильное действие:

```jsx
const increment = () => {
    return {
        type: 'counter/increment',
    }
}

store.dispatch(increment())

console.log(store.getState())
// {value: 2}
```

### Селекторов

**Селекторы** — это функции, которые знают, как извлекать определенные фрагменты информации из значения состояния хранилища. По мере роста приложения это может помочь избежать повторения логики, поскольку разные части приложения должны считывать одни и те же данные:

```jsx
const selectCounterValue = (state) => state.value

const currentValue = selectCounterValue(store.getState())
console.log(currentValue)
// 2
```

### Поток данных приложения Redux

Ранее мы говорили об «одностороннем потоке данных», который описывает эту последовательность шагов по обновлению приложения:

-   Состояние описывает состояние приложения в определенный момент времени
-   Пользовательский интерфейс отображается на основе этого состояния
-   Когда что-то происходит (например, пользователь нажимает кнопку), состояние обновляется в зависимости от того, что произошло.
-   Пользовательский интерфейс повторно отображается на основе нового состояния

В частности, для Redux мы можем разбить эти шаги более подробно:

-   Первоначальная настройка:
    -   Хранилище Redux создается с помощью функции корневого редьюсера
    -   Хранилище вызывает корневой редьюсер один раз и сохраняет возвращаемое значение в качестве исходного `state`
    -   При первой визуализации пользовательского интерфейса компоненты пользовательского интерфейса получают доступ к текущему состоянию хранилища Redux и используют эти данные, чтобы решить, что отображать. Они также подписываются на любые будущие обновления хранилища, чтобы знать, изменилось ли состояние.
-   Обновления:
    -   Что-то происходит в приложении, например, пользователь нажимает кнопку
    -   Код приложения отправляет действие в хранилищ Redux, например `dispatch({type: 'counter/increment'})`
    -   Хранилище снова запускает функцию редьюсера с предыдущим и текущим , и сохраняет возвращаемое значение как новое `stateactionstate`
    -   хранилищ уведомляет все части пользовательского интерфейса, на которые подписана подписка, о том, что хранилище было обновлено.
    -   Каждый компонент пользовательского интерфейса, которому требуются данные из хранилища, проверяет, изменились ли необходимые ему части состояния.
    -   Каждый компонент, который видит свои данные, изменился, принудительно перерисовывает новые данные, чтобы он мог обновлять то, что отображается на экране.

Вот как этот поток данных выглядит визуально:

![https://redux.js.org/assets/images/ReduxDataFlowDiagram-49fa8c3968371d9ef6f2a1486bd40a26.gif](https://redux.js.org/assets/images/ReduxDataFlowDiagram-49fa8c3968371d9ef6f2a1486bd40a26.gif)

##

## Пример приложения "Счетчик"

Пример проекта, который мы рассмотрим, представляет собой небольшое приложение счетчика, которое позволяет нам добавлять или вычитать число при нажатии кнопок. Это может быть не очень захватывающе, но это показывает все важные части приложения React + Redux в действии.

Проект был создан с использованием [официального шаблона Redux для Create-React-App](https://github.com/reduxjs/cra-template-redux). Из коробки он уже был настроен со стандартной структурой приложения Redux, используя [Redux Toolkit](https://redux-toolkit.js.org/) для создания хранилища и логики Redux и [React-Redux](https://react-redux.js.org/) для соединения хранилища Redux и компонентов React.

Вот живая версия проекта. Вы можете поиграть с ним, нажав кнопки в предварительном просмотре приложения

Если вы хотите попробовать создать этот проект на своем компьютере, вы можете [начать новый проект Create-React-App](https://create-react-app.dev/docs/getting-started#selecting-a-template), используя наш шаблон Redux:

```powershell
npx create-react-app redux-essentials-example --template redux

```

### Использование приложения "Счетчик"

Приложение счетчика уже настроено, чтобы мы могли наблюдать, что происходит внутри, когда мы его используем.

Откройте DevTools в браузере. Затем выберите вкладку «Redux» в DevTools и нажмите кнопку «Состояние» на панели инструментов в правом верхнем углу. Вы должны увидеть что-то, что выглядит следующим образом:

Справа мы видим, что наш хранилищ Redux начинается со значения состояния приложения, которое выглядит следующим образом:

```
{
  counter: {
    value: 0
  }
}

```

DevTools покажет нам, как меняется состояние хранилища при использовании приложения.

Давайте сначала поиграем с приложением, чтобы посмотреть, что оно делает. Нажмите кнопку «+» в приложении, затем посмотрите на вкладку «Diff» в Redux DevTools:

![https://redux.js.org/assets/images/devtools-first-action-c9d4378ec1ec3e1c8f93b1e8e4a1d033.png](https://redux.js.org/assets/images/devtools-first-action-c9d4378ec1ec3e1c8f93b1e8e4a1d033.png)

Здесь мы видим две важные вещи:

-   Когда мы нажали кнопку «+», в хранилищ было отправлено действие с типом`"counter/increment"`
-   Когда это действие было отправлено, поле изменилось с на `state.counter.value01`

Теперь попробуйте выполнить следующие действия:

-   Нажмите кнопку «+» еще раз. Теперь отображаемое значение должно быть равно 2.
-   Нажмите кнопку "-" один раз. Теперь отображаемое значение должно быть равно 1.
-   Нажмите кнопку "Добавить сумму". Теперь отображаемое значение должно быть равно 3.
-   Измените число "2" в текстовом поле на "3"
-   Нажмите кнопку "Добавить асинхронный". Вы должны увидеть индикатор выполнения, заполняющий кнопку, и через пару секунд отображаемое значение должно измениться на 6.

Вернитесь в Redux DevTools. Вы должны увидеть в общей сложности пять отправленных действий, по одному за каждый раз, когда мы нажимали кнопку. Теперь выберите последнюю запись из списка слева, и нажмите на вкладку «Действие» справа:`"counter/incrementByAmount"`

![https://redux.js.org/assets/images/devtools-done-clicking-8826e622b87734ea2a0044233a2a642f.png](https://redux.js.org/assets/images/devtools-done-clicking-8826e622b87734ea2a0044233a2a642f.png)

Мы видим, что этот объект действия выглядел следующим образом:

```
{
  type: 'counter/incrementByAmount',
  payload: 3
}

```

И если вы нажмете на вкладку «Diff», вы увидите, что поле изменилось с a на a в ответ на это действие.`state.counter.value36`

Возможность видеть, что происходит внутри нашего приложения и как наше состояние меняется с течением времени, очень мощная!

DevTools имеет еще несколько команд и опций, которые помогут вам отладить ваше приложение. Попробуйте щелкнуть вкладку «Трассировка» в правом верхнем углу. На панели должна появиться трассировка стека функций JavaScript с несколькими разделами исходного кода, показывающими строки, которые выполнялись, когда действие достигало хранилища. В частности, следует выделить одну строку: строку кода, куда мы отправили это действие из компонента:`<Counter>`

![https://redux.js.org/assets/images/devtools-action-stacktrace-8ee180838c97840a749b9209e80c8a72.png](https://redux.js.org/assets/images/devtools-action-stacktrace-8ee180838c97840a749b9209e80c8a72.png)

Это упрощает отслеживание того, какая часть кода отправляет конкретное действие.

## Содержание приложения

Теперь, когда вы знаете, что делает приложение, давайте посмотрим, как оно работает.

Вот ключевые файлы, которые составляют это приложение:

-   `/src`

    -   `index.js`

        : отправная точка для приложения

    -   `App.js`

        : компонент React верхнего уровня

    -   `/app`

        -   `store.js`

            : создает экземпляр хранилища Redux

    -   `/features`

        -   `/counter`

            -   `Counter.js`

                : компонент React, отображающий пользовательский интерфейс для функции счетчика

            -   `counterSlice.js`

                : логика Redux для функции счетчика

Давайте начнем с того, как создается хранилищ Redux.

### Создание хранилища Redux

Откройте , который должен выглядеть следующим образом:`app/store.js`

```jsx
import { configureStore } from '@reduxjs/toolkit'
import counterReducer from '../features/counter/counterSlice'

export default configureStore({
    reducer: {
        counter: counterReducer,
    },
})
```

хранилищ Redux создается с помощью функции из Redux Toolkit. требует, чтобы мы передали аргумент.`configureStoreconfigureStorereducer`

Наше приложение может состоять из множества различных функций, и каждая из этих функций может иметь свою собственную функцию редьюсера. Когда мы звоним, мы можем передать все различные редьюсеры в объекте. Имена ключей в объекте будут определять ключи в нашем конечном значении состояния.`configureStore`

У нас есть файл с именем, который экспортирует функцию редьюсера для логики счетчика. Мы можем импортировать эту функцию сюда и включить ее при создании хранилища.`features/counter/counterSlice.jscounterReducer`

Когда мы передаем такой объект, как , это говорит о том, что мы хотим иметь раздел нашего объекта состояния Redux, и что мы хотим, чтобы функция отвечала за принятие решения о том, обновлять ли раздел при отправке действия и как.`{counter: counterReducer}state.countercounterReducerstate.counter`

Redux позволяет настраивать настройку хранилища с помощью различных видов плагинов («промежуточное ПО» и «усилители»). по умолчанию автоматически добавляет несколько промежуточных программ в настройку хранилища, чтобы обеспечить хорошее взаимодействие с разработчиком, а также настраивает хранилище таким образом, чтобы расширение Redux DevTools могло проверять его содержимое.`configureStore`

### Фрагменты Redux

**«Срез» — это коллекция логики редьюсера Redux и действий для одного компонента в приложении**, обычно определяемых вместе в одном файле. Название происходит от разделения корневого объекта состояния Redux на несколько «срезов» состояния.

Например, в приложении для ведения блогов настройка нашего хранилища может выглядеть следующим образом:

```jsx
import { configureStore } from '@reduxjs/toolkit'
import usersReducer from '../features/users/usersSlice'
import postsReducer from '../features/posts/postsSlice'
import commentsReducer from '../features/comments/commentsSlice'

export default configureStore({
    reducer: {
        users: usersReducer,
        posts: postsReducer,
        comments: commentsReducer,
    },
})
```

В этом примере , , и являются отдельным «срезом» состояния Redux. Поскольку он отвечает за обновление среза, мы называем его функцией «редьюсера среза».`state.usersstate.postsstate.commentsusersReducerstate.users`

### Создание редьюсеров и действий срезов

Поскольку мы знаем, что функция исходит от , давайте посмотрим, что находится в этом файле, по частям.`counterReducerfeatures/counter/counterSlice.js`

```jsx
import { createSlice } from '@reduxjs/toolkit'

export const counterSlice = createSlice({
    name: 'counter',
    initialState: {
        value: 0,
    },
    reducers: {
        increment: (state) => {
            // Redux Toolkit allows us to write "mutating" logic in reducers. It
            // doesn't actually mutate the state because it uses the immer library,
            // which detects changes to a "draft state" and produces a brand new
            // immutable state based off those changes
            state.value += 1
        },
        decrement: (state) => {
            state.value -= 1
        },
        incrementByAmount: (state, action) => {
            state.value += action.payload
        },
    },
})

export const { increment, decrement, incrementByAmount } = counterSlice.actions

export default counterSlice.reducer
```

Ранее мы видели, что нажатие различных кнопок в пользовательском интерфейсе отправляет три разных типа действий Redux:

-   `{type: "counter/increment"}`
-   `{type: "counter/decrement"}`
-   `{type: "counter/incrementByAmount"}`

Мы знаем, что действия — это простые объекты с полем, поле всегда представляет собой строку, и у нас обычно есть функции «создателя действия», которые создают и возвращают объекты действия. Так где же определены эти объекты действий, строки типов и создатели действий?`typetype`

Мы *могли бы* писать их все от руки, каждый раз. Но это было бы утомительно. Кроме того, что *действительно* важно в Redux, так это функции редьюсера и логика, которую они имеют для вычисления нового состояния.

Redux Toolkit имеет функцию под названием , которая заботится о работе по созданию строк типа действия, функций создателя действий и объектов действия. Все, что вам нужно сделать, это определить имя для этого фрагмента, написать объект, который имеет некоторые функции редьюсера, и он автоматически генерирует соответствующий код действия. Строка из параметра используется в качестве первой части каждого типа действия, а имя ключа каждой функции редьюсера используется в качестве второй части. Итак, имя + функция редьюсера сгенерировали тип действия . (В конце концов, зачем писать это от руки, если компьютер может сделать это за нас!)`createSlicename"counter""increment"{type: "counter/increment"}`

В дополнение к полю, нам нужно передать в исходное состояние значение для редьюсеров, так что есть первый раз, когда оно вызывается. В этом случае мы предоставляем объекту поле, которое начинается с 0.`namecreateSlicestatevalue`

Здесь мы видим, что есть три функции редьюсера, и это соответствует трем различным типам действий, которые были отправлены нажатием разных кнопок.

`createSlice` автоматически генерирует создателей действий с теми же именами, что и функции редьюсера, которые мы написали. Мы можем проверить это, позвонив одному из них и посмотрев, что он возвращает:

```jsx
console.log(counterSlice.actions.increment())
// {type: "counter/increment"}
```

Он также генерирует функцию редьюсера срезов, которая знает, как реагировать на все эти типы действий:

```jsx
const newState = counterSlice.reducer({ value: 10 }, counterSlice.actions.increment())
console.log(newState)
// {value: 11}
```

### Правила работы редьюсеров

Ранее мы говорили, что редьюсеры **всегда** должны соблюдать некоторые особые правила:

-   Они должны вычислять только новое значение состояния на основе аргументов and`stateaction`
-   Им не разрешается изменять существующие . Вместо этого они должны вносить *неизменяемые обновления*, копируя существующие и внося изменения в скопированные значения.`statestate`
-   Они не должны делать никакой асинхронной логики или других «побочных эффектов»

Но почему эти правила важны? Есть несколько разных причин:

-   Одна из целей Redux — сделать ваш код предсказуемым. Когда выходные данные функции вычисляются только из входных аргументов, легче понять, как работает этот код, и протестировать его.
-   С другой стороны, если функция зависит от переменных вне себя или ведет себя случайным образом, вы никогда не знаете, что произойдет при ее запуске.
-   Если функция изменяет другие значения, включая аргументы, это может неожиданно изменить способ работы приложения. Это может быть распространенным источником ошибок, таких как «Я обновил свое состояние, но теперь мой пользовательский интерфейс не обновляется, когда должен!»
-   Некоторые из возможностей Redux DevTools зависят от правильности соблюдения редьюсерами этих правил

Правило о «неизменяемых обновлениях» особенно важно, и о нем стоит поговорить дальше.

### Редьюсеры и неизменяемые обновления

Ранее мы говорили о «мутации» (изменение существующих значений объекта/массива) и «неизменности» (отношение к значениям как к чему-то, что не может быть изменено).

В Redux **нашим редьюсерам *никогда не* разрешается изменять исходные / текущие значения состояния!**

**ПРЕДУПРЕЖДЕНИЕ**

```jsx
// ❌ Illegal - by default, this will mutate the state!
state.value = 123
```

Есть несколько причин, по которым вы не должны мутировать состояние в Redux:

-   Это вызывает ошибки, такие как неправильное обновление пользовательского интерфейса для отображения последних значений
-   Это затрудняет понимание того, почему и как стейто было обновлено.
-   Это затрудняет написание тестов
-   Это нарушает возможность правильно использовать «отладку путешествий во времени»
-   Это идет вразрез с предполагаемым духом и шаблонами использования для Redux

Итак, если мы не можем изменить оригиналы, как мы можем вернуть обновленное состояние?

**КОНЧИК**

**Редьюсеры могут делать только *копии* исходных значений, а затем они могут мутировать копии.**

```jsx
// ✅ This is safe, because we made a copy
return {
    ...state,
    value: 123,
}
```

Мы уже видели, что [можем писать неизменяемые обновления вручную](https://redux.js.org/tutorials/essentials/part-1-overview-concepts#immutability), используя операторы разворота массивов / объектов JavaScript и другие функции, которые возвращают копии исходных значений. Однако, если вы думаете, что «написание неизменяемых обновлений вручную таким образом выглядит трудно запомнить и сделать правильно»... Да, Вы правы! :)

Писать неизменяемую логику *обновления вручную* сложно, а случайное изменение состояния в редьюсерах является единственной наиболее распространенной ошибкой пользователей Redux.

**Вот почему функция `createSlice` в Redux Toolkit позволяет писать неизменяемые обновления более простым способом!**

`createSlice` использует библиотеку под названием [Immer](https://immerjs.github.io/immer/) inside. Immer использует специальный инструмент JS, называемый a, для переноса предоставленных данных и позволяет писать код, который «мутирует» эти данные. Но **Immer отслеживает все изменения, которые вы пытались внести, а затем использует этот список изменений, чтобы вернуть безопасно неизменно обновленное значение**, как если бы вы записали всю неизменяемую логику обновления вручную.`Proxy`

Итак, вместо этого:

```jsx
function handwrittenReducer(state, action) {
    return {
        ...state,
        first: {
            ...state.first,
            second: {
                ...state.first.second,
                [action.someId]: {
                    ...state.first.second[action.someId],
                    fourth: action.someValue,
                },
            },
        },
    }
}
```

Вы можете написать код, который выглядит следующим образом:

```jsx
function reducerWithImmer(state, action) {
    state.first.second[action.someId].fourth = action.someValue
}
```

Это намного легче читать!

Но вот кое-что *очень* важное, что нужно помнить:

**ПРЕДУПРЕЖДЕНИЕ**

**Вы можете писать «мутирующую» логику *только* в `createSlice` и `createReducer` Redux Toolkit, потому что они используют Immer внутри! Если вы напишете мутирующую логику в редьюсерах без Immer, это *изменит* состояние и вызовет ошибки!**

Имея это в виду, давайте вернемся назад и посмотрим на фактические редьюсеры из `src/features/counter`

```JSX
export const counterSlice = createSlice({
  name: 'counter',
  initialState: {
    value: 0
  },
  reducers: {
    increment: state => {
      // Redux Toolkit allows us to write "mutating" logic in reducers. It
      // doesn't actually mutate the state because it uses the immer library,
      // which detects changes to a "draft state" and produces a brand new
      // immutable state based off those changes
      state.value += 1
    },
    decrement: state => {
      state.value -= 1
    },
    incrementByAmount: (state, action) => {
      state.value += action.payload
    }
  }
})

```

Мы видим, что редьюсер всегда будет добавлять 1 к . Поскольку Immer знает, что мы внесли изменения в объект черновика, нам не нужно ничего возвращать здесь. Таким же образом редьюсер вычитает 1.`incrementstate.valuestatedecrement`

В обоих этих редьюсерах нам на самом деле не нужно, чтобы наш код смотрел на объект. Он будет передан в любом случае, но поскольку он нам не нужен, мы можем пропустить объявление в качестве параметра для редьюсеров.`actionaction`

С другой стороны, *редьюсеру* нужно что-то знать: сколько он должен прибавлять к значению счетчика. Итак, мы заявляем, что редьюсер имеет и то, и другое, и аргументы. В этом случае мы знаем, что сумма, которую мы ввели в текстовое поле, помещается в поле, поэтому мы можем добавить это в .`incrementByAmountstateactionaction.payloadstate.value`

**ХОТИТЕ УЗНАТЬ БОЛЬШЕ?**

Для получения дополнительной информации о неизменности и написании неизменяемых обновлений см. [страницу документов «Неизменяемые шаблоны обновлений»](https://redux.js.org/usage/structuring-reducers/immutable-update-patterns) и [Полное руководство по неизменности в React и Redux](https://daveceddia.com/react-redux-immutability-guide/).

### Написание асинхронной логики с помощью Thunks

До сих пор вся логика в нашем приложении была синхронной. Действия отправляются, хранилище запускает редьюсеры и вычисляет новое состояние, и функция диспетчеризации завершается. Но язык JavaScript имеет много способов написания асинхронного кода, и наши приложения обычно имеют асинхронную логику для таких вещей, как извлечение данных из API. Нам нужно место, чтобы поместить эту асинхронную логику в наши приложения Redux.

**Thunk** — это особый вид функции Redux, который может содержать асинхронную логику. Thunks пишутся с использованием двух функций:

-   Внутренняя функция thunk, которая получает и в качестве аргументов`dispatch getState`
-   Функция внешнего создателя, которая создает и возвращает функцию thunk

Следующая функция, из которой экспортируется, является примером создателя действий thunk:`counterSlice`

```jsx
// The function below is called a thunk and allows us to perform async logic.
// It can be dispatched like a regular action: `dispatch(incrementAsync(10))`.
// This will call the thunk with the `dispatch` function as the first argument.
// Async code can then be executed and other actions can be dispatched
export const incrementAsync = (amount) => (dispatch) => {
    setTimeout(() => {
        dispatch(incrementByAmount(amount))
    }, 1000)
}
```

Мы можем использовать их так же, как мы используем типичный создатель действий Redux:

```jsx
store.dispatch(incrementAsync(5))
```

Однако использование thunks требует, чтобы *промежуточное ПО* (тип плагина для Redux) было добавлено в хранилищ Redux при его создании. К счастью, функция Redux Toolkit уже настраивает это для нас автоматически, поэтому мы можем пойти дальше и использовать здесь thunks.`redux-thunk configureStore`

Когда вам нужно выполнить вызовы AJAX для получения данных с сервера, вы можете поместить этот вызов в thunk. Вот пример, который написан немного длиннее, чтобы вы могли видеть, как он определен:

`src/features/counter/counterSlice.js`

```jsx
// the outside "thunk creator" function
const fetchUserById = (userId) => {
    // the inside "thunk function"
    return async (dispatch, getState) => {
        try {
            // make an async call in the thunk
            const user = await userAPI.fetchById(userId)
            // dispatch an action when we get the response back
            dispatch(userLoaded(user))
        } catch (err) {
            // If something went wrong, handle it here
        }
    }
}
```

Мы увидим использование thunks в [Части 5: Асинхронная логика и извлечение данных](https://redux.js.org/tutorials/essentials/part-5-async-logic)

В этом файле есть еще одна функция, но мы поговорим об этом через минуту, когда посмотрим на компонент пользовательского интерфейса.`<Counter>`

**ХОТИТЕ УЗНАТЬ БОЛЬШЕ?**

Смотрите [документы Redux Thunk](https://github.com/reduxjs/redux-thunk), пост [Что, черт возьми, такое thunk?](https://daveceddia.com/what-is-a-thunk/) и [запись Redux FAQ на тему «Почему мы используем промежуточное ПО для асинхронности?»](https://redux.js.org/faq/actions#how-can-i-represent-side-effects-such-as-ajax-calls-why-do-we-need-things-like-action-creators-thunks-and-middleware-to-do-async-behavior) для получения дополнительной информации.

### Компонент счетчика реакций

Ранее мы видели, как выглядит автономный компонент React. Наше приложение React+ Redux имеет аналогичный компонент, но оно делает несколько вещей по-другому.`<Counter><Counter>`

Мы начнем с просмотра файла компонента:`Counter.js`

```jsx
import React, { useState } from 'react'
import { useSelector, useDispatch } from 'react-redux'
import { decrement, increment, incrementByAmount, incrementAsync, selectCount } from './counterSlice'
import styles from './Counter.module.css'

export function Counter() {
    const count = useSelector(selectCount)
    const dispatch = useDispatch()
    const [incrementAmount, setIncrementAmount] = useState('2')

    return (
        <div>
            <div className={styles.row}>
                <button className={styles.button} aria-label="Increment value" onClick={() => dispatch(increment())}>
                    +
                </button>
                <span className={styles.value}>{count}</span>
                <button className={styles.button} aria-label="Decrement value" onClick={() => dispatch(decrement())}>
                    -
                </button>
            </div>
            {/* omit additional rendering output here */}
        </div>
    )
}
```

Как и в предыдущем примере с простым React, у нас есть компонент функции с именем , который хранит некоторые данные в хуке.`CounteruseState`

Однако в нашем компоненте не похоже, что мы храним фактическое текущее значение счетчика в состоянии. *Есть* переменная под названием , но она не исходит от крючка.`countuseState`

В то время как React включает в себя несколько встроенных хуков, таких как и , другие библиотеки могут создавать свои [собственные пользовательские хуки](https://reactjs.org/docs/hooks-custom.html), которые используют хуки React для создания пользовательской логики.`useStateuseEffect`

Библиотека [React-Redux](https://react-redux.js.org/) содержит [набор пользовательских хуков, которые позволяют компоненту React взаимодействовать с хранилищом Redux](https://react-redux.js.org/api/hooks).

### Чтение данных с помощью `useSelector`

Во-первых, хук позволяет нашему компоненту извлекать любые необходимые ему фрагменты данных из состояния хранилища Redux.`useSelector`

Ранее мы видели, что мы можем писать «селекторные» функции, которые принимают за аргумент и возвращают некоторую часть значения состояния.`state`

У нас есть эта функция селектора внизу:`counterSlice.js`

```jsx
// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state) => state.counter.value)`
export const selectCount = (state) => state.counter.value
```

Если бы у нас был доступ к хранилищу Redux, мы могли бы получить текущее значение счетчика следующим образом:

```jsx
const count = selectCount(store.getState())
console.log(count)
// 0
```

Наши компоненты не могут напрямую взаимодействовать с хранилищем Redux, поскольку нам не разрешается импортировать его в файлы компонентов. Но, позаботьтесь о том, чтобы поговорить с хранилищом Redux за кулисами для нас. Если мы передаем функцию селектора, она вызывает нас и возвращает результат.`useSelector someSelector(store.getState())`

Таким образом, мы можем получить текущее значение счетчика хранилища, выполнив:

```jsx
const count = useSelector(selectCount)
```

Нам также не нужно использовать *только* селекторы, которые уже были экспортированы. Например, мы могли бы записать функцию селектора в качестве встроенного аргумента в :`useSelector`

```jsx
const countPlusTwo = useSelector((state) => state.counter.value + 2)
```

Каждый раз, когда действие было отправлено и хранилище Redux было обновлено, мы повторно запускаем нашу функцию селектора. Если селектор возвращает значение, отличное от значения в прошлый раз, убедитесь, что наш компонент повторно отрисовывается с новым значением.`useSelector useSelector`

### действия с `useDispatch`

Точно так же мы знаем, что если бы у нас был доступ к хранилищу Redux, мы могли бы отправлять действия с помощью создателей действий, таких как . Поскольку у нас нет доступа к самому хранилищу, нам нужен какой-то способ получить доступ только к методу.`store.dispatch(increment())dispatch`

Крючок делает это за нас и дает нам фактический метод из хранилища Redux:`useDispatchdispatch`

```jsx
const dispatch = useDispatch()
```

Оттуда мы можем отправлять действия, когда пользователь делает что-то вроде нажатия на кнопку:

**функции/счетчик/счетчик.js**

```jsx
<button className={styles.button} aria-label="Increment value" onClick={() => dispatch(increment())}>
    +
</button>
```

### Состояние компонента и формы

К настоящему времени вы можете задаться вопросом: «Всегда ли мне нужно помещать все состояние моего приложения в хранилищ Redux?»

Ответ – **НЕТ. Глобальное состояние, необходимое для всего приложения, должно находиться в хранилище Redux. Состояние, необходимое только в одном месте, должно храниться в состоянии компонента.**

В этом примере у нас есть текстовое поле ввода, где пользователь может ввести следующее число, добавляемое в счетчик:

```jsx
const [incrementAmount, setIncrementAmount] = useState('2')

// later
return (
    <div className={styles.row}>
        <input
            className={styles.textbox}
            aria-label="Set increment amount"
            value={incrementAmount}
            onChange={(e) => setIncrementAmount(e.target.value)}
        />
        <button className={styles.button} onClick={() => dispatch(incrementByAmount(Number(incrementAmount) || 0))}>
            Add Amount
        </button>
        <button className={styles.asyncButton} onClick={() => dispatch(incrementAsync(Number(incrementAmount) || 0))}>
            Add Async
        </button>
    </div>
)
```

Мы *могли бы* сохранить текущую строку чисел в хранилище Redux, отправив действие в обработчик входных данных и сохранив его в нашем редьюсере. Но это не дает нам никакой пользы. Единственное место, где используется текстовая строка, находится здесь, в компоненте. (Конечно, в этом примере есть только один другой компонент: . Но даже если бы у нас было более крупное приложение с большим количеством компонентов, заботится только об этом входном значении.)`onChange<Counter><App><Counter>`

Таким образом, имеет смысл сохранить это значение в крючке здесь, в компоненте.`useState<Counter>`

Точно так же, если бы у нас был логический флаг под названием , никакие другие компоненты в приложении не позаботились бы об этом - он действительно должен оставаться локальным для этого компонента.`isDropdownOpen`

**В приложении React + Redux ваше глобальное состояние должно находиться в хранилище Redux, а локальное состояние должно оставаться в компонентах React.**

Если вы не уверены, куда что-то поместить, вот некоторые общие эмпирические правила для определения того, какие данные должны быть помещены в Redux:

-   Заботятся ли другие части приложения об этих данных?
-   Нужно ли вам иметь возможность создавать дополнительные производные данные на основе этих исходных данных?
-   Используются ли одни и те же данные для управления несколькими компонентами?
-   Есть ли ценность для вас в том, чтобы иметь возможность восстановить это состояние до заданного момента времени (т.е. отладка путешествий во времени)?
-   Вы хотите кэшировать данные (т. Е. Использовать то, что находится в состоянии, если оно уже есть, а не повторно запрашивать его)?
-   Вы хотите сохранить эти данные согласованными при горячей перезагрузке компонентов пользовательского интерфейса (которые могут потерять свое внутреннее состояние при замене)?

Это также хороший пример того, как думать о формах в Redux в целом. **Большая часть форм состояния, вероятно, не должна храниться в Redux.** Вместо этого сохраняйте данные в компонентах формы во время их редактирования, а затем отправляйте действия Redux для обновления хранилища, когда пользователь закончит.

Еще одна вещь, которую следует отметить, прежде чем мы продолжим: помните, что стук из ? Мы используем его здесь, в этом компоненте. Обратите внимание, что мы используем его так же, как мы отправляем других создателей обычных действий. Этому компоненту все равно, отправляем ли мы обычное действие или запускаем асинхронную логику. Он знает только, что когда вы нажимаете эту кнопку, он что-то отправляет.`increment Async counterSlice.js`

### Предоставление хранилища

Мы видели, что наши компоненты могут использовать крючки для общения с хранилищом Redux. Но, поскольку мы не импортировали хранилищ, как эти крючки узнают, с каким хранилищом Redux разговаривать?`useSelectoruseDispatch`

Теперь, когда мы увидели все различные части этого приложения, пришло время вернуться к начальной точке этого приложения и посмотреть, как последние части головоломки сочетаются друг с другом.

```jsx
import React, { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import { Provider } from 'react-redux'
import './index.css'
import App from './App'
import store from './app/store'
import * as serviceWorker from './serviceWorker'

const rootElement = document.getElementById('root')
const root = createRoot(rootElement)

root.render(
    <StrictMode>
        <Provider store={store}>
            <App />
        </Provider>
    </StrictMode>
)
```

Мы всегда должны помнить, чтобы сказать React, чтобы начать рендеринг нашего корневого компонента. Для того, чтобы наши хуки работали правильно, нам нужно использовать компонент, вызванный для передачи хранилища Redux за кулисами, чтобы они могли получить к нему доступ.`ReactDOM.render(<App />) <App>useSelector<Provider>`

Мы уже создали наше хранилище поэтому мы можем импортировать его сюда. Затем мы помещаем наш компонент вокруг всего , и передаем в хранилище: .`app/store.js<Provider><App><Provider store={store}>`
Теперь любые компоненты React, которые вызывают или будут использовать хранилище Redux, имеют `useSelector useDispatch <Provider>`

## Что вы узнали

Несмотря на то, что пример приложения счетчика довольно мал, он показал все ключевые части приложения React + Redux, работающие вместе.

**СВОДКА**

-   **Мы можем создать хранилище Redux с помощью API `api репозитория Redux Toolkit configureStore`**

    -   `configureStorereducer`

        принимает функцию в качестве именованного аргумента

    -   `configureStore`

        автоматически настраивает хранилищ с хорошими настройками по умолчанию

-   **Логика Redux обычно организована в файлы, называемые «срезами»**
    -   «Срез» содержит логику редьюсера и действия, связанные с определенной функцией / разделом состояния Redux
    -   API Redux Toolkit генерирует создателей действий и типы действий для каждой отдельной функции редьюсера, которую вы предоставляете`createSlice`
-   **Редьюсеры Redux должны следовать определенным правилам**
    -   Следует вычислять только новое значение состояния на основе аргументов and`stateaction`
    -   Необходимо сделать *неизменяемые обновления*, скопировав существующее состояние
    -   Не может содержать асинхронную логику или другие «побочные эффекты»
    -   API Redux Toolkit использует Immer, чтобы позволить «мутировать» неизменяемые обновления`createSlice`
-   **Асинхронная логика обычно пишется в специальных функциях, называемых «thunks»**
    -   Thunks получают и в качестве аргументов`dispatchgetState`
    -   Redux Toolkit включает промежуточное ПО по умолчанию`redux-thunk`
-   **React-Redux позволяет компонентам React взаимодействовать с хранилищом Redux**
    -   Упаковка приложения позволяет всем компонентам использовать хранилищ`<Provider store={store}>`
    -   Глобальное состояние должно идти в хранилище Redux, локальное состояние должно оставаться в компонентах React
